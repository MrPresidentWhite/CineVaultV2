# Staging: Lint + Test parallel, dann Build → Staging-Report (Grok + Discord) → bei Erfolg wird Deploy getriggert
# Läuft bei Push auf main. Deploy-Workflow startet nur, wenn Staging erfolgreich durchläuft.
# "Abgebrochen" ohne Fehlermeldung: oft ein älterer Lauf, der durch concurrency abgebrochen wurde
# (neuer Push = neuer Lauf, vorheriger wird cancelled). Im Actions-Tab den neuesten Lauf prüfen.
# Secrets: DISCORD_STAGING_WEBHOOK, GROK_API_URL, GROK_API_KEY, GROK_API_MODEL, NEXT_SERVER_ACTIONS_ENCRYPTION_KEY

name: Staging

on:
  push:
    branches: [main]

concurrency:
  group: staging-main
  cancel-in-progress: true

env:
  SESSION_SECRET: "ci-build-placeholder-not-used-at-runtime"
  DATABASE_URL: "postgresql://ci:ci@localhost:5432/ci"
  NEXT_SERVER_ACTIONS_ENCRYPTION_KEY: ${{ secrets.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY }}

jobs:
  lint:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - uses: actions/cache@v4
        id: node-cache
        with:
          path: node_modules
          key: node-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            node-${{ runner.os }}-

      - name: Install dependencies
        if: steps.node-cache.outputs.cache-hit != 'true'
        run: npm ci

      - name: Prisma generate
        run: npm run db:generate

      - name: Lint
        id: lint
        continue-on-error: true
        run: |
          npm run lint 2>&1 | tee lint.txt
          exit ${PIPESTATUS[0]}

      - uses: actions/upload-artifact@v4
        with:
          name: lint-output
          path: lint.txt

      - name: Lint-Fehler durchreichen
        if: steps.lint.outcome == 'failure'
        run: exit 1

  test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - uses: actions/cache@v4
        id: node-cache
        with:
          path: node_modules
          key: node-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            node-${{ runner.os }}-

      - name: Install dependencies
        if: steps.node-cache.outputs.cache-hit != 'true'
        run: npm ci

      - name: Prisma generate
        run: npm run db:generate

      - name: Test
        id: test
        continue-on-error: true
        run: |
          npm test 2>&1 | tee test.txt
          exit ${PIPESTATUS[0]}

      - uses: actions/upload-artifact@v4
        with:
          name: test-output
          path: test.txt

      - name: Test-Fehler durchreichen
        if: steps.test.outcome == 'failure'
        run: exit 1

  build:
    runs-on: ubuntu-latest
    needs: [lint, test]
    if: always() && (needs.lint.result != 'cancelled' && needs.test.result != 'cancelled')
    permissions:
      contents: read
      actions: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - uses: actions/download-artifact@v4
        with:
          name: lint-output
          path: .

      - uses: actions/download-artifact@v4
        with:
          name: test-output
          path: .

      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - uses: actions/cache@v4
        id: node-cache
        with:
          path: node_modules
          key: node-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            node-${{ runner.os }}-

      - name: Install dependencies
        if: steps.node-cache.outputs.cache-hit != 'true'
        run: npm ci

      - name: Prisma generate
        run: npm run db:generate

      - uses: actions/cache@v4
        id: next-cache
        with:
          path: .next/cache
          key: next-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-${{ hashFiles('src/**', 'prisma/schema.prisma', 'next.config.ts', 'tsconfig.json') }}
          restore-keys: |
            next-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-

      - name: Build
        id: build
        run: |
          npm run build 2>&1 | tee build.txt
          exit ${PIPESTATUS[0]}

      - name: "Standalone: .next/static und public ergänzen"
        if: steps.build.outcome == 'success'
        run: |
          # Next.js standalone enthält .next/static und public NICHT automatisch.
          # Ohne diese fehlen Client-JS-Chunks → Client Components (z.B. PasskeyLoginButton) rendern nicht.
          cp -r .next/static .next/standalone/.next/
          cp -r public .next/standalone/ 2>/dev/null || mkdir -p .next/standalone/public

      - name: Artifact hochladen (next-standalone)
        if: steps.build.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: next-standalone
          path: .next/standalone

      - name: Logging-Check (keine Secrets in Logs, v2 Abschnitt 15.3)
        id: logging-check
        continue-on-error: true
        run: node scripts/staging-logging-check.mjs logging-check.txt || exit 1

      - name: Job-Logs herunterladen (für Discord-Anhang)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p _joblogs && cd _joblogs
          JOBS_JSON=$(curl -sS -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs")
          JOB_ID=$(echo "$JOBS_JSON" | jq -r '.jobs[] | select(.name == "build") | .id // empty' | head -1)
          if [ -z "$JOB_ID" ] || [ "$JOB_ID" = "null" ]; then
            JOB_ID=$(echo "$JOBS_JSON" | jq -r '.jobs[0].id // empty')
          fi
          if [ -z "$JOB_ID" ] || [ "$JOB_ID" = "null" ]; then
            echo "Job-ID nicht gefunden." > staging-job-logs.txt
          else
            curl -sSL -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/jobs/${JOB_ID}/logs" -o logs.zip
            if [ -f logs.zip ] && [ -s logs.zip ]; then
              unzip -o -q logs.zip 2>/dev/null || true
              find . -type f ! -name "*.zip" 2>/dev/null | sort -V | while read -r f; do
                echo "--- ${f} ---" >> staging-job-logs.txt
                cat "$f" 2>/dev/null >> staging-job-logs.txt
                echo "" >> staging-job-logs.txt
              done
            fi
          fi
          [ -s staging-job-logs.txt ] || echo "Keine Logs verfügbar." > staging-job-logs.txt
          mv staging-job-logs.txt .. && cd .. && rm -rf _joblogs

      - name: Staging-Report an Discord (mit Grok + Log-Anhang)
        if: always()
        env:
          LINT_OUTCOME: ${{ needs.lint.result }}
          TEST_OUTCOME: ${{ needs.test.result }}
          BUILD_OUTCOME: ${{ steps.build.outcome }}
          LOGGING_CHECK_OUTCOME: ${{ steps.logging-check.outcome }}
          DISCORD_STAGING_WEBHOOK: ${{ secrets.DISCORD_STAGING_WEBHOOK }}
          GROK_API_URL: ${{ secrets.GROK_API_URL }}
          GROK_API_KEY: ${{ secrets.GROK_API_KEY }}
          GROK_API_MODEL: ${{ secrets.GROK_API_MODEL }}
        run: node scripts/staging-report-discord.mjs lint.txt test.txt build.txt logging-check.txt staging-job-logs.txt

      - name: Staging fehlgeschlagen
        if: always() && (needs.lint.result == 'failure' || needs.test.result == 'failure' || steps.build.outcome == 'failure' || steps.logging-check.outcome == 'failure')
        run: |
          echo "Mindestens ein Check (Lint/Tests/Build/Logging-Check) ist fehlgeschlagen. Kein Deployment."
          exit 1
