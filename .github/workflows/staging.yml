# Staging: Lint, Tests, Build → Staging-Report (Grok + Discord) → bei Erfolg wird Deploy getriggert
# Läuft bei Push auf main. Deploy-Workflow startet nur, wenn Staging erfolgreich durchläuft.
# "Abgebrochen" ohne Fehlermeldung: oft ein älterer Lauf, der durch concurrency abgebrochen wurde
# (neuer Push = neuer Lauf, vorheriger wird cancelled). Im Actions-Tab den neuesten Lauf prüfen.
# Secrets: DISCORD_STAGING_WEBHOOK, GROK_API_URL, GROK_API_KEY, GROK_API_MODEL

name: Staging

on:
  push:
    branches: [main]

concurrency:
  group: staging-main
  cancel-in-progress: true

jobs:
  staging:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      # write für actions/cache (Speichern des Caches; inkl. Lesen)
      actions: write
    env:
      # Nur für CI-Build: src/lib/env.ts verlangt in Prod SESSION_SECRET und getDatabaseUrl() DB-Config.
      # Echte Prod nutzt Secrets aus der Server-.env; hier reichen Platzhalter (kein echter DB-Zugriff).
      SESSION_SECRET: "ci-build-placeholder-not-used-at-runtime"
      DATABASE_URL: "postgresql://ci:ci@localhost:5432/ci"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Cache node_modules
        id: node-cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            node-${{ runner.os }}-

      - name: Install dependencies
        if: steps.node-cache.outputs.cache-hit != 'true'
        run: npm ci

      - name: Prisma generate
        run: npm run db:generate

      - name: Cache Next.js build
        id: next-cache
        uses: actions/cache@v4
        with:
          path: .next/cache
          key: next-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-${{ hashFiles('src/**', 'prisma/schema.prisma', 'next.config.ts', 'tsconfig.json') }}
          restore-keys: |
            next-${{ runner.os }}-${{ hashFiles('package-lock.json') }}-

      - name: Lint
        id: lint
        continue-on-error: true
        run: |
          npm run lint 2>&1 | tee lint.txt
          exit ${PIPESTATUS[0]}

      - name: Test
        id: test
        continue-on-error: true
        run: |
          npm test 2>&1 | tee test.txt
          exit ${PIPESTATUS[0]}

      - name: Build
        id: build
        run: |
          npm run build 2>&1 | tee build.txt
          exit ${PIPESTATUS[0]}

      - name: Logging-Check (keine Secrets in Logs, v2 Abschnitt 15.3)
        id: logging-check
        continue-on-error: true
        run: node scripts/staging-logging-check.mjs logging-check.txt || exit 1

      - name: Job-Logs herunterladen (für Discord-Anhang)
        if: always()
        run: |
          mkdir -p _joblogs && cd _joblogs
          JOB_ID=$(curl -sS -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" \
            | jq -r '.jobs[] | select(.name == env.GITHUB_JOB) | .id')
          if [ -z "$JOB_ID" ] || [ "$JOB_ID" = "null" ]; then
            echo "Job-ID nicht gefunden." > staging-job-logs.txt
          else
            curl -sSL -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/jobs/${JOB_ID}/logs" -o logs.zip
            if [ -f logs.zip ] && [ -s logs.zip ]; then
              unzip -o -q logs.zip || true
              ls -1 *.txt 2>/dev/null | sort -V | xargs cat > staging-job-logs.txt 2>/dev/null || true
            fi
          fi
          [ -s staging-job-logs.txt ] || echo "Keine Logs verfügbar." > staging-job-logs.txt
          mv staging-job-logs.txt .. && cd .. && rm -rf _joblogs

      - name: Staging-Report an Discord (mit Grok + Log-Anhang)
        if: always()
        env:
          LINT_OUTCOME: ${{ steps.lint.outcome }}
          TEST_OUTCOME: ${{ steps.test.outcome }}
          BUILD_OUTCOME: ${{ steps.build.outcome }}
          LOGGING_CHECK_OUTCOME: ${{ steps.logging-check.outcome }}
          DISCORD_STAGING_WEBHOOK: ${{ secrets.DISCORD_STAGING_WEBHOOK }}
          GROK_API_URL: ${{ secrets.GROK_API_URL }}
          GROK_API_KEY: ${{ secrets.GROK_API_KEY }}
          GROK_API_MODEL: ${{ secrets.GROK_API_MODEL }}
        run: node scripts/staging-report-discord.mjs lint.txt test.txt build.txt logging-check.txt staging-job-logs.txt

      - name: Staging fehlgeschlagen
        if: always() && (steps.lint.outcome == 'failure' || steps.test.outcome == 'failure' || steps.build.outcome == 'failure' || steps.logging-check.outcome == 'failure')
        run: |
          echo "Mindestens ein Check (Lint/Tests/Build/Logging-Check) ist fehlgeschlagen. Kein Deployment."
          exit 1
